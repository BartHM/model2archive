Subject:  v08i095:  Query terminal for its type
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: Michael A. Cooper <usc-oberon!mcooper>
Mod.sources: Volume 8, Issue 95
Archive-name: qterm

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  README Makefile table.c qterm.c qterm.1 local.h
# Wrapped by root@coupon on Sun Sep  4 11:38:44 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(936 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X		 Q T E R M  -  Q U E R Y   T E R M I N A L
X
X         		     Revision 1.23
X			     January, 1987
X
X	Qterm is a program that queries terminals to find out what kind
Xof terminal is responding.  It is useful to automagically define your
Xterminal type.  It prints the name of the terminal (compatible, hopefully,
Xwith a termcap/terminfo name) such as "vt100" to standard output.
XSee the manual for details.
X
X	Qterm was written under 4.2BSD and will probably run without 
Xmodification on other Berkeley Unix systems.  It has been tested under
X4.2BSD, 4.3BSD, Sun 3.0 and Sun 3.2.  It should work under System V.2,
Xbut I have not personally tested it on such a system.  (For System V.2,
Xcompile with USG5 defined).
X
X
X				Mike
X
X
XMichael A. Cooper, University Computing Services, U of Southern California
X  UUCP: {sdcrdcf, uscvax}!usc-oberon!mcooper  BITNET: mcooper@uscvaxq
X  ARPA: mcooper@usc-oberon.USC.EDU            PHONE: (213) 743-3462
END_OF_FILE
if test 936 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(521 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# $Header: Makefile,v 1.1 86/12/22 10:45:46 mcooper Exp $
X#
X# Makefile for QTERM
X#
XBIN=/usr/local
XMAN=/usr/usc/man/man1
X
XOBJS = qterm.o table.o
X
X#
X# Use "-DUSG5" for $(CFLAGS) below, if your system is Unix System V.
X# Edit the defines in qterm.c, local.h was added for the Tandy 6000
XCFLAGS = -O
X
Xqterm: $(OBJS)
X	cc $(CFLAGS) $(OBJS) -o qterm
X
Xshar:
X	shar README Makefile table.c qterm.c qterm.1 local.h > qterm.shar
X
Xclean:
X	rm -f *.o core log 
X
Xinstall: qterm qterm.1
X	install qterm $(BIN)
X	install -c qterm.1 $(MAN)
END_OF_FILE
if test 521 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'table.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'table.c'\"
else
echo shar: Extracting \"'table.c'\" \(2400 characters\)
sed "s/^X//" >'table.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Header: table.c,v 1.3 86/11/13 15:40:26 mcooper Locked $";
X#endif
X
X/*
X *------------------------------------------------------------------
X *
X * $Source: /big/mcooper/src/qterm/RCS/table.c,v $
X * $Revision: 1.3 $
X * $Date: 86/11/13 15:40:26 $
X * $State: Exp $
X * $Author: mcooper $
X * $Locker: mcooper $
X *
X *------------------------------------------------------------------
X *
X * Michael A. Cooper
X * University Computing Services, 
X * University of Southern California
X * (mcooper@usc-oberon.arpa)
X *
X *------------------------------------------------------------------
X * $Log:	table.c,v $
X * Revision 1.3  86/11/13  15:40:26  mcooper
X * z29 -> h29.  "h29" is recognized
X * more.
X * 
X * Revision 1.2  86/07/01  23:13:04  mcooper
X * Added vt220 and f220 entries.
X * 
X * Revision 1.1  86/07/01  22:58:12  mcooper
X * Initial revision
X * 
X *------------------------------------------------------------------
X */
X
X#include <stdio.h>
X
X/*
X * The Master Table
X */
Xchar *terms[] = {
X/*  Terminal Sends:			Terminal Name: 	Real Name: 		*/
X/*	---------------			-------------- 	---------- 		*/
X	"\33[?1;0c",			"vt100",		"Base vt100",
X	"\33[?1;1c",			"vt100",		"vt100 with STP",
X	"\33[?1;2c",			"vt100",		"ANSI/VT100 Clone",
X	"\33[?1;3c",			"vt100",		"vt100 with AVO and STP",
X	"\33[?1;4c",			"vt100",		"vt100 with GPO",
X	"\33[?1;5c",			"vt100",		"vt100 with GPO and STP",
X	"\33[?1;6c",			"vt100",		"vt100 with GPO and AVO",
X	"\33[?1;7c",			"vt100",		"vt100 with GPO, STP, and AVO",
X	"\33[?6c",				"vt100",		"Generic vt100",
X	"\33[?8c",				"vt100",		"TeleVideo 970",
X	"\33[0n",				"vt100",		"AT&T Unix PC 7300",
X	"\33[?l;0c",			"vt100",		"AT&T Unix PC 7300",
X	"\33[?12c",				"vt100",		"Concept from Pro 350/UNIX",
X	"\33[?;c",				"vt100",		"Concept From Pro 350/UNIX",
X	"\33[=1;1c",			"avt-4p-s",		"Concept with 4 pages memory",
X	"\33[=1;2c",			"avt-8p-s",		"Concept with 8 pages memory",
X	"\33iBO",				"h29",			"Zenith z29 in zenith mode",
X	"\33/K",				"h29",			"Zenith z29 in zenith mode",
X	"\33/Z",				"vt52",			"Generic vt52",
X	"\33[?12;7;0;102c",		"vt125",		"DEC Pro 350 in vt125 mode",
X	"\33[?10c",				"la120",		"DEC Writer III",
X	"\33[?1;11c",			"cit101e",		"CIE CIT-101 Enhanced w/Graphics",
X/*	"\33[?1;11c",			"xt100+",		"Northern Tech LANPARSCOPE",	*/
X	"\33[?62;1;2;6;7;8;9c",	"vt220",		"DEC VT220",
X	"\33[62;1;2;6;8c",		"f220",			"Freedom 220 DEC clone",
X	NULL
X};
END_OF_FILE
if test 2400 -ne `wc -c <'table.c'`; then
    echo shar: \"'table.c'\" unpacked with wrong size!
fi
# end of 'table.c'
fi
if test -f 'qterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qterm.c'\"
else
echo shar: Extracting \"'qterm.c'\" \(16423 characters\)
sed "s/^X//" >'qterm.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Header: qterm.c,v 1.23 87/01/09 13:55:44 mcooper Locked $";
X#endif
X
X/*
X *------------------------------------------------------------------
X *
X * $Source: /big/src/usc/bin/qterm/RCS/qterm.c,v $
X * $Revision: 1.23 $
X * $Date: 87/01/09 13:55:44 $
X * $State: Exp $
X * $Author: mcooper $
X * $Locker: mcooper $
X *
X *------------------------------------------------------------------
X *
X * Michael A. Cooper
X * University Computing Services, 
X * University of Southern California
X * (mcooper@usc-oberon.arpa)
X *
X *------------------------------------------------------------------
X * $Log:	qterm.c,v $
X * Revision 1.23  87/01/09  13:55:44  mcooper
X * Fixed bug with -s option that caused "ers:" 
X * to be printed instead of the string
X * received from the terminal.
X * 
X * Revision 1.22  86/12/11  15:57:16  mcooper
X * Should now work under System V thanks to Brian L. Matthews
X * (cxsea!blm).
X * 
X * Revision 1.21  86/10/13  12:52:54  mcooper
X * Fixed bug that caused problems with
X * send strings not being sent from .qterm
X * files.
X * 
X * Revision 1.20  86/08/25  15:45:58  mcooper
X * BUG FIX: When the -f flag was specified and the user's
X *          tables did not produce the terminal's entry,
X *          the internal terminal tables where not tried
X *          as documented.
X * 
X * Revision 1.19  86/08/12  15:31:22  mcooper
X * Fixed bug that caused terminals to wedge due
X * to qterm failing to match receive strings
X * from the .qterm file.
X * 
X * Revision 1.18  86/08/11  13:49:42  mcooper
X * Fixed bug that caused qterm to wedge.  Problem
X * due to alarms not being set correctly.
X * 
X * Revision 1.17  86/08/08  14:40:09  mcooper
X * - Only send/listen for strings if the previously sent string
X *   is not the same as the current string.
X * - Fixed -s option.
X * 
X * Revision 1.16  86/08/08  13:16:05  mcooper
X * Major re-write: Added ~/.qterm file that contains
X * the users own copy of terminal tables.
X * 
X * Revision 1.15  86/07/21  12:35:54  mcooper
X * Now works under System V (Define USG5).
X * 
X * Revision 1.14  86/07/01  22:57:45  mcooper
X * Moved terminal table to seperate
X * file (table.c).
X * 
X * Revision 1.13  86/06/30  11:17:53  mcooper
X * More terminals to main table...
X * 
X * Revision 1.12  86/06/19  13:57:51  mcooper
X * Added responses for concept from a Pro running
X * 2.9bsd.
X * 
X * Revision 1.11  86/06/18  15:58:45  mcooper
X * Cleanup for release.
X * 
X * Revision 1.10  86/06/17  23:06:55  mcooper
X * Added Unix PC responses.
X * 
X * Revision 1.9  86/06/16  14:19:09  mcooper
X * Added vt100 responses from vt100 manual.
X * 
X * Revision 1.8  86/06/16  13:23:40  mcooper
X * Print additional information about
X * what the actual terminal is.
X * 
X * Revision 1.7  86/06/12  10:59:27  mcooper
X * *** empty log message ***
X * 
X * Revision 1.6  86/06/11  19:48:35  mcooper
X * Added alternate string and table entries for concepts.
X * 
X * Revision 1.5  86/05/19  12:30:32  mcooper
X * General clean up.
X * 
X * Revision 1.4  86/05/18  17:56:11  mcooper
X * Added another vt100.  This one is for when you rlogin
X * from a Pro 2.9bsd host on a HDS Concept.
X * 
X * Revision 1.3  86/05/08  09:24:13  mcooper
X * Added another vt100 description.
X * 
X * Revision 1.2  86/05/06  18:23:35  mcooper
X * More cleanup - de-linted (almost).
X * 
X * Revision 1.1  86/05/06  14:56:57  mcooper
X * Initial revision
X * 
X *------------------------------------------------------------------
X */
X
X/*
X * [Edit with tabstop=4]
X *
X * qterm - Query Terminal
X *
X * qterm is used to query a terminal to determine the name of the terminal.
X * This is done by sending a fairly universal string "\33Z" to the terminal,
X * reading in a response, and comparing it against a master table of responses
X * and names.  The "name" printed to standard output should be one found in
X * the termcap(5) database.
X *
X * Putting a line in your ".login" file such as:
X *
X *	setenv TERM `qterm`
X *
X * or the following lines in your ".profile" file:
X *
X *	TERM=`qterm`
X *	export TERM
X *
X * will set your terminal type automagically.
X * 
X * If you add a terminal to the master table, please also send me a copy
X * so that I may put it into my version.
X *
X * Michael Cooper
X * ARPA: 	mcooper@usc-oberon.ARPA
X * UUCP: 	mcooper@usc-oberon.UUCP
X * BITNET:	mcooper@uscvaxq
X */
X
X#include <stdio.h>
X#include <pwd.h>
X#include <signal.h>
X#include <sys/ioctl.h>
X#include <setjmp.h>
X#ifdef USG5
X# include <termio.h>
X#else
X/*# include <sys/file.h>*/	/* local.h added and file.h commented out */
X# include "local.h"		/* for the Tandy 6000 */
X# include <sgtty.h>
X#endif
X
X#define SEND		"\033Z"		/* send this to query terminal */
X#define ALTSEND		"\033[c"	/* alternate string */
X
X#define STRFILE		"/usr/local/qterm.tab"	/* file containing terminal strings */
X
X#define dprintf		if(debug)printf
X#define MAXTERMS	100
X
X#define TRUE		1
X#define FALSE		0
X
X#define T_STR		0
X#define T_NAME		1
X#define T_LNAME		2
X
Xint tabmark = 0;
Xint tabtotal = 0;
Xint has_set = 0;
X
X
X#define BUF			666
X
Xstruct qt {
X	char	qt_sendstr[BUFSIZ]; 		/* String to send to terminal */
X	char	qt_recvstr[BUFSIZ];			/* String expected in response */
X	char	qt_termname[BUFSIZ];		/* Terminal name */
X	char	qt_fullname[BUFSIZ];		/* Full terminal name & description */
X};
Xstruct qt *compare();
Xstatic struct qt termtab[MAXTERMS];
X
X
X#ifdef USG5
Xstruct termio _ntty, _otty;
X#else
Xstruct sgttyb _tty;
X#endif
Xint _tty_ch = 2;
X
X#ifdef USG5
X# define crmode()		(_ntty.c_lflag &= ~ICANON,\
X						 _ntty.c_cc[VMIN] = 1, _ntty.c_cc[VTIME] = 0,\
X						 ioctl(_tty_ch, TCSETAF, &_ntty))
X# define nocrmode()		(_ntty.c_lflag |= ICANON,\
X						 _ntty.c_cc[VMIN] = _otty.c_cc[VMIN],\
X						 _ntty.c_cc[VTIME] = _otty.c_cc[VTIME],\
X						 ioctl(_tty_ch, TCSETAF, &_ntty))
X# define echo()			(_ntty.c_lflag |= ECHO,\
X						 ioctl(_tty_ch, TCSETAF, &_ntty))
X# define noecho()		(_ntty.c_lflag &= ~ECHO,\
X						 ioctl(_tty_ch, TCSETAF, &_ntty))
X#else
X# define crmode() 		(_tty.sg_flags |= CBREAK,\
X							ioctl(_tty_ch, TIOCSETP, &_tty))
X# define nocrmode() 	(_tty.sg_flags &= ~CBREAK,\
X							ioctl(_tty_ch, TIOCSETP, &_tty))
X# define echo() 		(_tty.sg_flags |= ECHO,   \
X							ioctl(_tty_ch, TIOCSETP, &_tty))
X# define noecho() 		(_tty.sg_flags &= ~ECHO,  \
X							ioctl(_tty_ch, TIOCSETP, &_tty))
X#endif
X
X#define SIZE 		512
X#define CMASK 		0377
X#define ESC			'\033'
X
Xstatic char recvbuf[SIZE];
Xstatic char *progname;
Xint debug;					/* debug mode 			*/
Xint aflag;					/* alternate string 	*/
Xint sflag;					/* print strings		*/
Xint qflag;					/* quiet mode 			*/
Xint fflag;					/* use strings file 	*/
X
Xint found = FALSE;
Xint index = 0;
Xint finish(), wakeup(), done();
X
Xchar *decode();
X
Xjmp_buf env;
X
Xmain(argc, argv)
Xchar *argv[];
X{
X	register int x;
X
X	progname = argv[0];
X
X	for (x = 1; x < argc; x++) {
X		if (argv[x][0] != '-')
X			break;
X		switch (argv[x][1]) {
X			case 'a':
X				aflag = TRUE;
X				break;
X			case 't':
X			case 's':
X				sflag = TRUE;
X				break;
X			case 'q':
X				qflag = TRUE;
X				break;
X			case 'f':
X				fflag = TRUE;
X				break;
X			case 'd':
X				debug = TRUE;
X				break;
X			default:
X				usage();
X				exit(1);
X		}
X	}
X
X	setbuf(stdout, 0);
X	if(debug)
X		setbuf(stderr, 0);
X
X	dprintf("[ %s debug mode enabled ]\n\n", progname);
X
X	if(!isatty(0))
X		fprintf(stderr,"Not a tty.\n");
X
X#ifdef USG5
X	if(ioctl(_tty_ch, TCGETA, &_otty) < 0)
X#else
X	if(ioctl(_tty_ch, TIOCGETP, &_tty) < 0)
X#endif
X	{
X		perror("gtty");
X		exit(1);
X	}
X#ifdef USG5
X	_ntty = _otty;
X#endif
X	if(crmode() < 0) {
X		perror("crmode");
X		exit(1);
X	}
X	if(noecho() < 0) {
X		perror("noecho");
X		exit(1);
X	}
X
X	dprintf("[ initilizing term table... ]\n");
X	mktable();
X	dprintf("[ table done ]\n");
X
X	if(!fflag) {
X		dointernal();
X	} else
X		dprintf("!fflag.  not doing dointernal().\n");
X
X	index = tabmark;
X	dprintf("main: we'll do a dotab()\n");
X	dotab();
X	dprintf("main: dotab done\n");
X
X	putc('\r', stderr);
X	(void) nocrmode();
X	(void) echo();
X	if(!found) {
X		dprintf("end of main\n");
X		notrecognized();
X	}
X}
X
Xdone()
X{
X	putc('\r', stderr);
X	(void) nocrmode();
X	(void) echo();
X	exit(0);
X}
X
X/*
X * finish - clean things up.
X */
Xfinish()
X{
X	dprintf("finish called\n");
X	putc('\r', stderr);
X	(void) nocrmode();
X	(void) echo();
X	if(recvbuf[0] != NULL)
X		(void) prinfo(compare(recvbuf, 0, tabtotal), 1);
X		
X	dprintf("finish done\n");
X	if(!found)
X		notrecognized();
X	exit(0);
X}
X
Xprinfo(t, what)
Xstruct qt *t;
Xint what;
X{
X	int len = 0;
X	int st = FALSE;
X
X	dprintf("prinfo startup\n");
X	if((t->qt_termname[0] != NULL) && (recvbuf[0] != NULL)) {
X		if(debug || sflag) {
X			len = strlen(recvbuf);
X			fprintf(stderr, "%s receives %d character%s:", 
X				progname, len, (len == 1) ? "" : "s");
X			fprintf(stderr, " %s\n", decode(recvbuf));
X		}
X		if(!qflag)
X			if(t->qt_fullname[0] != NULL)
X				fprintf(stderr, "Terminal recognized as %s (%s)\n", 
X					t->qt_termname, t->qt_fullname);
X			else
X				fprintf(stderr, "Terminal recognized as %s\n", 
X					t->qt_termname);
X		printf("%s\n", t->qt_termname);
X		found = TRUE;
X		done();
X		/*NOTREACHED*/
X	} else {
X		found = FALSE;
X		if(what) {
X			dprintf("prinfo(): doing notrecognized()\n");
X			notrecognized();
X			done();
X			/*NOTREACHED*/
X		}
X	}
X	dprintf("prinfo done\n");
X	return(st);
X}
X
X/*
X * compare - actually compare what we received against the table.
X */
Xstruct qt *
Xcompare(str, start, stop)
Xchar *str;
Xint start;
Xint stop;
X{
X	register int i = 0;
X	int len;
X
X	dprintf("compare(%s, %d, %d) startup.\n", decode(str), start, stop);
X	alarm(0);
X
X	i = start;
X	while(i <= stop) {
X		dprintf("compare(): tr = '%s'\n", decode(termtab[i].qt_recvstr));
X		if(strncmp(str, termtab[i].qt_recvstr, 
X		  strlen(termtab[i].qt_recvstr)) == 0) {
X			found = TRUE;
X			return(&termtab[i]);
X		}
X		++i;
X	}
X	found = FALSE;
X}
X
X/*
X * getch - read in a character at a time.
X */
Xgetch()
X{
X	char c;
X
X	(void) read(0, &c, 1);
X	return(c & CMASK);
X}
X
X/*
X * decode - print str in a readable fashion
X */
Xchar *
Xdecode(str)
Xchar *str;
X{
X	char buf[BUFSIZ];
X	char tmp[10];
X
X	strcpy(buf, "");
X	while(*str) {
X		if (*str == ESC) {
X			strcat(buf, "<esc> ");
X		} else if((*str <= 33) || (*str >= 127)) {
X			sprintf(tmp,"\\%o ", *str);
X			strcat(buf, tmp);
X		} else {
X			sprintf(tmp,"%c ", *str);
X			strcat(buf, tmp);
X		}
X		*++str;
X	}
X	return(buf);
X}
X
Xusage()
X{
X	fprintf(stderr, "usage: %s [ -asq ]\n", progname);
X}
X
Xmktable()
X{
X	register int i, z;
X	FILE *fd, *fopen();
X	char file[BUFSIZ];
X	char buf[BUFSIZ];
X	char lbuf[4][BUFSIZ];
X	char *home, *msg, *fixctl();
X	int iserr = 0;
X	extern char *terms[];
X	struct passwd *pwd;
X
X	i = z = 0;
X	/*
X	 * Copy internal table
X	 */
X	while(terms[z] != NULL && i < MAXTERMS) {
X		(void) strcpy(termtab[i].qt_sendstr, (aflag) ? ALTSEND : SEND);
X		(void) strcpy(termtab[i].qt_recvstr, terms[z + T_STR]);
X		(void) strcpy(termtab[i].qt_termname, terms[z + T_NAME]);
X		(void) strcpy(termtab[i].qt_fullname, terms[z + T_LNAME]);
X
X		z += 3;
X		++i;
X	}
X	tabmark = i;
X
X	/*
X	 * Try and read the user's own table
X	 */
X	if((home = (char *) getenv("HOME")) == NULL) {
X		if((pwd = (struct passwd *) getpwuid(getuid())) == NULL) {
X			fprintf(stderr, "Who the hell are you????\n");
X			exit(1);
X		}
X		home = pwd->pw_dir;
X	}
X	dprintf("home = '%s'\n", home);
X	sprintf(file, "%s/%s", home, STRFILE);
X	dprintf("strfile = '%s'\n", file);
X	if(fflag && (fd = fopen(file, "r")) != NULL) {
X		while(fgets(buf, sizeof(buf), fd) && i < MAXTERMS) {
X			if(buf[0] == '#' || buf[0] == '\n')
X				continue;
X
X			lbuf[0][0] = NULL;
X			lbuf[1][0] = NULL;
X			lbuf[2][0] = NULL;
X			lbuf[3][0] = NULL;
X	
X			(void) sscanf(buf, "%s%s%s\t%[^\n]", 
X				lbuf[0], lbuf[1], lbuf[2], lbuf[3]);
X			if(lbuf[0][0] == NULL)
X				continue;
X			if(lbuf[1][0] == NULL) {
X				iserr = TRUE;
X				msg = "receive string";
X			}
X			if(lbuf[2][0] == NULL) {
X				iserr = TRUE;
X				msg = "terminal name";
X			}
X			if(iserr) {
X				fprintf(stderr, "%s: Error parsing %s.\n", file, msg);
X				exit(1);
X			}
X			(void) strcpy(termtab[i].qt_sendstr, fixctl(lbuf[0]));
X			(void) strcpy(termtab[i].qt_recvstr, fixctl(lbuf[1]));
X			(void) strcpy(termtab[i].qt_termname, lbuf[2]);
X			(void) strcpy(termtab[i].qt_fullname, lbuf[3]);
X
X			dprintf("entry %d:\n", i);
X			dprintf("qt_sendstr = %s\n", decode(termtab[i].qt_sendstr));
X			dprintf("qt_recvstr = %s\n", decode(termtab[i].qt_recvstr));
X			dprintf("qt_termname = '%s'\n", termtab[i].qt_termname);
X			dprintf("qt_fullname = '%s'\n", termtab[i].qt_fullname);
X
X			++i;
X		}
X	}
X	tabtotal = i;
X	dprintf("termtab total  = %d\n", tabtotal);
X	dprintf("termtab mark  = %d\n", tabmark);
X}
X
Xlisten(q)
Xstruct qt *q;
X{
X	register int i;
X	register char c;
X	char end, begin;
X
X	dprintf("listen startup\n");
X	alarm(0);
X
X	dprintf("listen: listening for '%s'\n", decode(q->qt_recvstr));
X
X	if (q->qt_recvstr[0] == NULL) {
X		begin = ESC;
X		end = 'c';
X	} else {
X		begin = q->qt_recvstr[0];
X		end = q->qt_recvstr[strlen(q->qt_recvstr)-1];
X	}
X
X	dprintf("listen: read initial character...\n");
X	if(setjmp(env)) {
X		dprintf("listen: setjmp TRUE\n");
X		if(found)
X			done();
X		++index;
X		(void) fflush(stdin);
X		dprintf("listen: dotab()\n");
X		dotab();
X	} else {
X		dprintf("listen: setjmp FALSE...set alarm\n");
X		signal(SIGALRM, wakeup);
X		alarm(3);
X		dprintf("listen: read char\n");
X		recvbuf[0] = getch();
X		alarm(0);
X		dprintf("recvbuf[0] = '\\%o'\n", recvbuf[0]);
X
X	}
X	i = 0;
X	if(recvbuf[0] == begin) {
X		dprintf("listen begin\n");
X		while(c != end) {
X			if(setjmp(env))  {
X				dprintf("listen: setjmp (2) return\n");
X				return;
X			} else {
X				signal(SIGALRM, wakeup);
X				alarm(2);
X				dprintf("listen: read (2) char\n");
X				c = getch();
X				alarm(0);
X				dprintf("recvbuf[0] = '\\%o'\n", recvbuf[0]);
X			}
X			recvbuf[++i] = c;
X		}
X		if(debug)
X			fprintf(stderr,"\n[ Received terminator. ]\n");
X	} else {
X		dprintf("listen: Not Recognized.  exiting...\n");
X		notrecognized();
X		putc('\r',stderr);
X		(void) nocrmode();
X		(void) echo();
X		exit(1);
X	}
X	dprintf("listen done\n");
X}
X
Xnotrecognized()
X{
X	if(!qflag)
X		fprintf(stderr, 
X		  "Terminal NOT recognized - defaults to \"dumb\".\n");
X	puts("dumb");
X}
X
Xwakeup()
X{
X	dprintf("wakeup called\n");
X	longjmp(env, 1);
X	dprintf("wakeUP: done\n");
X}
X
Xdotab()
X{
X	int wakeup();
X	int st = FALSE;
X	static int firsttime = TRUE;
X
X	dprintf("dotab startup\n");
X	dprintf("index = %d\n", index);
X	if(index > tabtotal) {
X		/*
X		 * if we haven't reset things yet, do so.
X		 * now try the internal tables if the user's
X		 * tables failed.
X		 */
X		if(!has_set)  {
X			tabtotal = tabmark;
X			index = 0;
X			has_set = 1;
X			dprintf("dotab(): has_set now true.\n");
X			dotab();
X		}
X		dprintf("dotab(): index > tabtotal\n");
X		finish();
X	}
X	if(!found || fflag) {
X		while(!found && termtab[index].qt_sendstr[0] != NULL && !st) {
X			dprintf("dotab: termtab PASS %d\n", index);
X			dprintf("dotab: sending str %s\n", 
X				decode(termtab[index].qt_sendstr));
X			(void) fflush(stdin);
X			if(firsttime || strncmp(termtab[index].qt_sendstr, 
X			  termtab[index-1].qt_sendstr,
X			  strlen(termtab[index].qt_sendstr))) {
X				firsttime = FALSE;
X				dprintf("dotab(): sendstr's didn't match.\n");
X				dprintf("dotab: str1 %s\n", 
X					decode(termtab[index].qt_sendstr));
X				dprintf("dotab: str2 %s\n", 
X					decode(termtab[index-1].qt_sendstr));
X				fprintf(stderr, termtab[index].qt_sendstr);
X				(void) fflush(stdout);
X				(void) fflush(stderr);
X				(void) listen(&termtab[index]);
X			} else {
X				dprintf("dotab(): sendstr's DID match.  No str sent.\n");
X				dprintf("dotab: str1 %s\n", 
X					decode(termtab[index].qt_sendstr));
X				dprintf("dotab: str2 %s\n", 
X					decode(termtab[index-1].qt_sendstr));
X			}
X
X			firsttime = FALSE;
X			dprintf("dotab(): recbuf = '%s'\n", decode(recvbuf));
X			dprintf("dotab(): qt_rec = '%s'\n", 
X				decode(termtab[index].qt_recvstr));
X			st = prinfo(compare(recvbuf, tabmark, tabtotal), !fflag);
X			dprintf("st = %d\n", st);
X			++index;
X		}
X		dprintf("dotab(): mark 1\n");
X	}
X	dprintf("i'm here (2)\n");
X	if(!found) {
X		dprintf("end of dotab\n");
X		dointernal();
X		if(!found) {
X			dprintf("dotab: dointernal failed.\n");
X			notrecognized();
X		}
X	}
X	done();
X}
X
Xdointernal()
X{
X	struct qt q;
X
X	dprintf("DOINTERNAL startup.\n");
X
X	(void) fflush(stdin);
X	fprintf(stderr, (aflag) ? ALTSEND : SEND);
X	(void) fflush(stdout);
X	(void) fflush(stderr);
X
X	q.qt_recvstr[0] = NULL;
X
X	(void) listen(&q);
X
X	(void) prinfo(compare(recvbuf, 0, tabmark), 1);
X	if(found)
X		done();
X
X	dprintf("dointernal end.\n");
X}
X
Xchar *
Xfixctl(str)
Xchar *str;
X{
X	register int i;
X	char buf[BUFSIZ];
X
X	i = 0;
X	while(*str) {
X		if(*str == '^')
X			buf[i++] = *++str & 037;
X		else
X			buf[i++] = *str;
X		*++str;
X	}
X	buf[i] = NULL;
X	return(buf);
X}
END_OF_FILE
if test 16423 -ne `wc -c <'qterm.c'`; then
    echo shar: \"'qterm.c'\" unpacked with wrong size!
fi
# end of 'qterm.c'
fi
if test -f 'qterm.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qterm.1'\"
else
echo shar: Extracting \"'qterm.1'\" \(3333 characters\)
sed "s/^X//" >'qterm.1' <<'END_OF_FILE'
X.\"
X.\" $Header: qterm.1,v 1.1 86/12/22 10:45:25 mcooper Exp $
X.\"
X.TH QTERM 1 8/8/86
X.ds ]W USC Computing Services
X.SH NAME
Xqterm - Query Terminal
X.SH SYNOPSIS
Xqterm 
X[
X.B \-a
X]
X[
X.B \-f
X]
X[
X.B \-s
X]
X[
X.B \-q
X]
X.SH DESCRIPTION
X.I Qterm
Xis used to query a terminal to determine its name.
XThis is done by sending the fairly universal 
Xstring ``<ESCAPE>Z'' to the terminal,
Xreading in a response, and comparing it against a master table of possible
Xresponses.
XThe ``name'' printed to standard output should be one found in
Xthe
X.I termcap(5) 
Xdatabase.
X.PP
XFor 
X.I csh(1) 
Xusers,
Xputting a line in your 
X.I .login 
Xfile such as:
X.sp 1
X.in +.5i
Xsetenv TERM `qterm`
X.in -.5i
X.sp 1
Xshould automagically set your terminal type.
XFor 
X.I sh(1)
Xusers, putting these lines in your 
X.I .profile 
Xfile should set your terminal type:
X.sp 1
X.in +.5i
XTERM=`qterm`
X.br
Xexport TERM
X.in -.5i
X.sp 1
X.SH OPTIONS
X.IP \-a
XUse the alternate string ``<ESCAPE>[c'' when asking the terminal to
Xidentify itself.  This string is recognized by most ANSI compatible
Xterminals.
X.IP \-f
XIf the file
X.B $HOME/.qterm
Xis present, it's contents are scanned to produce information for
Xquerying terminals.  In this way, a user may setup different values
Xfor certain terminals.
XAfter the contents of this file have been scanned, 
X.I qterm
Xproceeds to query the terminal with the information provided
Xin the file
X.B $HOME/.qterm.
XIf an un-intelligable response is received (or non at all), 
X.I qterm
Xwill proceed to use its own internal information to determine the terminal
Xtype.
X.IP \-s
XDisplay the response received from
Xthe terminal in a ``nice'' fashion.
X.IP \-q
XBe ``quiet'' and only print the terminal name to standard
Xoutput.
X.SH ".QTERM FILE"
X.PP
XThe format of the file
X$HOME/.qterm
Xconsists of four fields each seperated by white space (tabs and/or spaces).
XThe first field is the string that should be used to query the terminal.
XThe second field is the string to expect in response to the query.
XThe third field is the terminal name (compatible with 
X.I termcap(5))
Xto print to standard output.
XThe fourth field is optional and may contain a description of the exact
Xmanufacturer and model name of the terminal to be used in a message
Xprinted to standard error.
X.PP
XBlank lines or lines starting with the character ``#''
Xare ignored and may be used as comment lines.
XA character preceeded by a ``^'' is taken to mean the 
X.I control
Xcharacter.  (i.e. ``^['' is interpretted as an <ESCAPE>).
X.PP
XBelow is a sample file:
X.sp 2
X.nf
X	#
X	# QTerm File
X	#
X	^[Z\0\0\0\0\0^[[?1;1c\0\0\0\0\0vt100\0\0\0\0\0A vt100 with STP
X	^[Z\0\0\0\0\0^[[?1;2c\0\0\0\0\0vt100\0\0\0\0\0ANSI/VT100 Clone
X	^[Z\0\0\0\0\0^[[?1;3c\0\0\0\0\0vt100\0\0\0\0\0A vt100 with AVO and STP
X	^[Z\0\0\0\0\0^[[?1;4c\0\0\0\0\0vt100\0\0\0\0\0A vt100 with GPO
X	^[Z\0\0\0\0\0^[iBO\0\0\0\0\0\0\0\0z29\0\0\0\0\0\0\0Zenith in Zenith Mode
X.fi
X.sp
X.SH AUTHOR
XMichael A. Cooper, 
X.br
XUSC Computing Services, Los Angeles.
X.SH FILES
X/etc/termcap	\- termcap(5) database
X.SH SEE ALSO
Xcsh(1), sh(1), termcap(5)
X.SH DIAGNOSTICS
X.IP "\fITerminal not recognized - defaults to dumb.\fP"
X.I QTerm
Xdid not receive a response from the terminal, or the response
Xdid not match any that 
X.I qterm 
Xhas stored internally.  Use the \-s option to check to see which
Xis the case.
X.SH BUGS
XMany terminals do not send a response at all.
END_OF_FILE
if test 3333 -ne `wc -c <'qterm.1'`; then
    echo shar: \"'qterm.1'\" unpacked with wrong size!
fi
# end of 'qterm.1'
fi
if test -f 'local.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'local.h'\"
else
echo shar: Extracting \"'local.h'\" \(646 characters\)
sed "s/^X//" >'local.h' <<'END_OF_FILE'
X/* local.h - definitions for use with
X *      Learning to Program in C
X */
X#ifndef FAIL
X#include <stdio.h>
X#define FAIL		1
X#define FOREVER		for (;;)
X#define NO			0
X#define STDERR		2
X#define STDIN		0
X#define STDOUT		1
X#define SUCCEED		0
X#define YES			1
X#define bits		ushort
X#define bool		int
X#define metachar	short
X#define tbool		char
X#define ushort      unsigned  /* use unsigned short, if you can */
X#define void		int
X#define getln(s, n) ((fgets(s, n, stdin)==NULL) ? EOF : strlen(s))
X#define ABS(x)		(((x) < 0) ? -(x) : (x))
X#define MAX(x, y)	(((x) < (y)) ? (y) : (x))
X#define MIN(x, y)	(((x) < (y)) ? (x) : (y))
X#endif
END_OF_FILE
if test 646 -ne `wc -c <'local.h'`; then
    echo shar: \"'local.h'\" unpacked with wrong size!
fi
# end of 'local.h'
fi
echo shar: End of shell archive.
exit 0
